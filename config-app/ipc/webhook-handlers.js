const { ipcMain } = require('electron');
const fs = require('fs');
const path = require('path');
const https = require('https');
const http = require('http');
const { PLUGINS_DIR } = require('../lib/config-service');

const WEBHOOK_PLUGIN_FILE = path.join(PLUGINS_DIR, 'feishu-webhook.js');
const WEBHOOK_CONFIG_FILE = path.join(PLUGINS_DIR, 'feishu-webhook-config.json');

function generatePluginCode() {
  const lines = [
    '// Feishu Webhook Notification Plugin for OpenCode',
    '// Auto-generated by Super OpenCode Config App',
    '// å®˜æ–¹æ’ä»¶æ ¼å¼: https://opencode.ai/docs/plugins',
    '',
    'import { readFileSync, existsSync } from "fs";',
    'import { join, dirname } from "path";',
    'import { fileURLToPath } from "url";',
    '',
    'const __dirname = dirname(fileURLToPath(import.meta.url));',
    'const CONFIG_PATH = join(__dirname, "feishu-webhook-config.json");',
    '',
    'function loadConfig() {',
    '  try {',
    '    if (existsSync(CONFIG_PATH)) {',
    '      return JSON.parse(readFileSync(CONFIG_PATH, "utf-8"));',
    '    }',
    '  } catch (e) {',
    '    console.error("[feishu-webhook] Failed to load config:", e.message);',
    '  }',
    '  return { enabled: false };',
    '}',
    '',
    'async function sendFeishuMessage(webhookUrl, title, content, template = "blue") {',
    '  try {',
    '    const payload = {',
    '      msg_type: "interactive",',
    '      card: {',
    '        header: {',
    '          title: { tag: "plain_text", content: title },',
    '          template: template',
    '        },',
    '        elements: [{',
    '          tag: "markdown",',
    '          content: content',
    '        }]',
    '      }',
    '    };',
    '',
    '    const response = await fetch(webhookUrl, {',
    '      method: "POST",',
    '      headers: { "Content-Type": "application/json" },',
    '      body: JSON.stringify(payload)',
    '    });',
    '',
    '    const result = await response.json();',
    '    if (result.code !== 0 && result.StatusCode !== 0) {',
    '      console.error("[feishu-webhook] Send failed:", result.msg);',
    '    }',
    '  } catch (e) {',
    '    console.error("[feishu-webhook] Error:", e.message);',
    '  }',
    '}',
    '',
    'export const FeishuNotificationPlugin = async ({ context }) => {',
    '  const config = loadConfig();',
    '  ',
    '  return {',
    '    name: "feishu-webhook",',
    '    ',
    '    event: async ({ event }) => {',
    '      if (!config.enabled || !config.webhook_url) return;',
    '      ',
    '      const projectName = context?.cwd?.split("/").pop() || "Unknown";',
    '      const scenarios = config.scenarios || ["completion", "error", "confirmation"];',
    '      ',
    '      if (event.type === "session.idle" && scenarios.includes("completion")) {',
    '        await sendFeishuMessage(',
    '          config.webhook_url,',
    '          "\\u2705 OpenCode \\u4efb\\u52a1\\u5b8c\\u6210",',
    '          `**\\u9879\\u76ee**: ${projectName}\\n**\\u65f6\\u95f4**: ${new Date().toLocaleString("zh-CN")}\\n\\n\\u4efb\\u52a1\\u5df2\\u5b8c\\u6210\\uff0c\\u7b49\\u5f85\\u4e0b\\u4e00\\u6b65\\u6307\\u4ee4\\u3002`,',
    '          "green"',
    '        );',
    '      }',
    '      ',
    '      if (event.type === "session.error" && scenarios.includes("error")) {',
    '        await sendFeishuMessage(',
    '          config.webhook_url,',
    '          "\\u274c OpenCode \\u8fd0\\u884c\\u9519\\u8bef",',
    '          `**\\u9879\\u76ee**: ${projectName}\\n**\\u65f6\\u95f4**: ${new Date().toLocaleString("zh-CN")}\\n**\\u9519\\u8bef**: ${event.error?.message || "\\u53d1\\u751f\\u672a\\u77e5\\u9519\\u8bef"}`,',
    '          "red"',
    '        );',
    '      }',
    '      ',
    '      if (event.type === "permission.request" && scenarios.includes("confirmation")) {',
    '        await sendFeishuMessage(',
    '          config.webhook_url,',
    '          "\\ud83d\\udd14 OpenCode \\u9700\\u8981\\u786e\\u8ba4",',
    '          `**\\u9879\\u76ee**: ${projectName}\\n**\\u65f6\\u95f4**: ${new Date().toLocaleString("zh-CN")}\\n**\\u64cd\\u4f5c**: ${event.permission?.description || "\\u9700\\u8981\\u60a8\\u7684\\u786e\\u8ba4"}`,',
    '          "yellow"',
    '        );',
    '      }',
    '    }',
    '  };',
    '};',
    '',
    'export default FeishuNotificationPlugin;',
    ''
  ];
  return lines.join('\n');
}

function register() {
  ipcMain.handle('get-webhook-config', async () => {
    try {
      if (fs.existsSync(WEBHOOK_CONFIG_FILE)) {
        const config = JSON.parse(fs.readFileSync(WEBHOOK_CONFIG_FILE, 'utf-8'));
        const scenarios = config.scenarios || [];
        return {
          success: true,
          data: {
            type: 'feishu',
            url: config.webhook_url,
            enabled: config.enabled !== false,
            notify_permission: scenarios.includes('confirmation'),
            notify_idle: scenarios.includes('completion'),
            notify_error: scenarios.includes('error')
          }
        };
      }
      return { success: true, data: null };
    } catch (error) {
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('test-webhook', async (event, config) => {
    try {
      const payload = JSON.stringify({
        msg_type: 'interactive',
        card: {
          header: {
            title: { tag: 'plain_text', content: 'ðŸ§ª OpenCode æµ‹è¯•é€šçŸ¥' },
            template: 'blue'
          },
          elements: [{
            tag: 'markdown',
            content: '**çŠ¶æ€**: è¿žæŽ¥æˆåŠŸ\\n**æ—¶é—´**: ' + new Date().toLocaleString('zh-CN') + '\\n\\nè¿™æ˜¯ä¸€æ¡æ¥è‡ª Oh-My-OpenCode é…ç½®åº”ç”¨çš„æµ‹è¯•æ¶ˆæ¯ã€‚'
          }]
        }
      });

      const url = new URL(config.url);
      const options = {
        hostname: url.hostname,
        port: url.port || (url.protocol === 'https:' ? 443 : 80),
        path: url.pathname + url.search,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(payload)
        }
      };

      return new Promise((resolve) => {
        const protocol = url.protocol === 'https:' ? https : http;
        const req = protocol.request(options, (res) => {
          let data = '';
          res.on('data', chunk => data += chunk);
          res.on('end', () => {
            try {
              const result = JSON.parse(data);
              if (result.code === 0 || result.StatusCode === 0) {
                resolve({ success: true, message: 'æµ‹è¯•æ¶ˆæ¯å‘é€æˆåŠŸï¼' });
              } else {
                resolve({ success: false, error: result.msg || 'å‘é€å¤±è´¥' });
              }
            } catch (e) {
              resolve({ success: false, error: 'å“åº”è§£æžå¤±è´¥: ' + e.message });
            }
          });
        });

        req.on('error', (e) => {
          resolve({ success: false, error: 'è¯·æ±‚å¤±è´¥: ' + e.message });
        });

        req.setTimeout(10000, () => {
          req.destroy();
          resolve({ success: false, error: 'è¯·æ±‚è¶…æ—¶' });
        });

        req.write(payload);
        req.end();
      });
    } catch (error) {
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('save-webhook-plugin', async (event, config) => {
    try {
      if (!fs.existsSync(PLUGINS_DIR)) {
        fs.mkdirSync(PLUGINS_DIR, { recursive: true });
      }

      const pluginCode = generatePluginCode();
      fs.writeFileSync(WEBHOOK_PLUGIN_FILE, pluginCode);

      const scenarios = [];
      if (config.notify_permission) scenarios.push('confirmation');
      if (config.notify_idle) scenarios.push('completion');
      if (config.notify_error) scenarios.push('error');

      const pluginConfig = {
        enabled: config.enabled !== false,
        webhook_url: config.url,
        scenarios: scenarios,
        created_at: new Date().toISOString()
      };
      fs.writeFileSync(WEBHOOK_CONFIG_FILE, JSON.stringify(pluginConfig, null, 2));
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  });
}

module.exports = { register };
